#Problem 29 from Project Euler
#Solution by Paul Barton
#
#Here is the text of the problem:
#Consider all integer combinations of a^(b) for 2 <= a <= 5 and 2 <= b <= 5:
#
#2^(2)=4, 2^(3)=8, 2^(4)=16, 2^(5)=32
#3^(2)=9, 3^(3)=27, 3^(4)=81, 3^(5)=243
#4^(2)=16, 4^(3)=64, 4^(4)=256, 4^(5)=1024
#5^(2)=25, 5^(3)=125, 5^(4)=625, 5^(5)=3125
#If they are then placed in numerical order, with any repeats removed, we get
#the following sequence of 15 distinct terms:
#
#4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
#
#How many distinct terms are in the sequence generated by a^(b) for 
#2 <= a <= 100 and 2 <= b <= 100?
#
#Consider the scale of this problem; without considering uniqueness, there will
#be 99^(2) numbers in a list, fewer than 10000. Once these numbers have been
#calculated, it is a simple matter to make up a unique list. The values are too
#large to use a technique like that used for the prime sieve for speed.

import time

#Python's built-in class, set, already has the functionality we need for making
#a list of only unique items. This is about as blunt as it gets, but it is still
#rather fast to execute. This problem does not scale very well due to the
#expense of checking uniqueness.

lower = 2
upper = 100

print('Plain algorithm:')
s = time.time()
nset = set()  # Instantiate a set
for i in xrange(lower, upper + 1):
    for j in xrange(lower, upper + 1):
        nset.add(i ** j)  # The add() method efficiently checks uniqueness
print('The solution is {0}'.format(len(nset)))
print('This took {0} seconds'.format(time.time() - s))

#Let's explore this further. Consider 4 in relation to 2. Being a square of 2,
#every 4^(n) will be represented by 2^(2n). Thus after computing 2^(n) for all
#n, only n > n/2 need to be considered for 4^(n). This will also apply to 8
#(n > n/3) in relation to 2. Notably, 16 in relation would work better than 16
#in relation to 2. It should be apparent that this principle could be used to
#improve the speed of the search. The following code provides some marginal
#gains in speed.

nset = set()
bases = range(lower, upper + 1)
exp = range(lower, upper + 1)
hexp = range(upper / 2, upper + 1)

def myfunc(num, nset, exp):
    for i in exp:
        nset.add(num ** i)
    squared = num ** 2
    if squared <= upper:
        nset = myfunc(bases.pop(bases.index(squared)), nset, hexp)
    return nset

print('Slightly optimized algorithm:')
t = time.time()
while bases:
    nset = myfunc(bases.pop(0), nset, exp)
print('The solution is {0}'.format(len(nset)))
print('This took {0} seconds'.format(time.time() - t))

